# 한 주간에 새로 배운 내용 정리
이번 주에 배운 UI 시스템 기능
- RectTransform
- Horizontal / Vertical Layout Group
- Scroll View
- EventSystem

C# 기능
- async
- Task

<br>

## 시작 시간
6시 43분(스샷 실수로 날림..)

<br>

# RectTransform
RectTransform은 UI에 사용되는 Transform이며, Transform 컴포넌트의 2D 레이아웃 버전이라고 생각하면 된다.

RectTransform의 Position과는 다르게 앵커를 기준으로 한 상대 위치이다. (숫자가 같아도 앵커의 위치에 따라 달라짐)

### Anchors
- UI의 기준점을 의미하며, 부모 기준에서 어느 위치로 잡을지 결정하는 속성이다.
- 해상도나 화면 비율이 바뀔때 UI가 깨지지 않게 해줄 수 있다.
- Anchors Presets으로 자주 쓰이는 옵션 몆 개를  간단하게 Preset으로 제공해준다.
- 오브젝트와 분리가 가능하다.

### Pivot
- UI의 중심점을 의미하며, 회전 - 확대 - 축소를 어느 기준으로 할지 결정하는 속성이다.

<br>

## 결론
RectTransform은 UI에서 사용하는 Transform 컴포넌트이며, Anchors와 Pivot을 이용하여 다양한 변화에 사용 가능한 UI를 구현하게 해주는 컴포넌트이다.

<br>

# Horizontal / Vertical Layout Group (그리드(행렬)는 아직 안배움)
Horizontal / Vertical Layout Group은 각각 UI 오브젝트들을 수평 / 수직으로 자동 정렬해주는 컴포넌트이다.

### Padding
- 부모 오브젝트 내부의 상하좌우에 얼마나 여백을 줄건지 정하는 속성

### Spacing 
- 자식 오브젝트의 사이에 얼마나 간격을 줄건지 정하는 속성

### Child Alignment
- 자식 오브젝트들이 부모 오브젝트의 어느 위치에 정렬될 것인지 정하는 속성

### Child Controls Size
- 자식 오브젝트의 SizeDelta를 Width / Height를 적용시킬지 정하는 속성

### Child Force Expand
- 부모 오브젝트의 공간에 맞춰서 자식 오브젝트가 공간을 최대한 채우도록 확장할지 정하는 속성
- 마지막 오브젝트 뒤에도 여백이 생김

<br>

## Layout Group의 장점
- 요소를 중간에 추가 / 삭제를 하여도 자동 정렬이라 UI 위치가 흐트러지지 않는다.
- 자동으로 간격, 크기조절, 정렬 등을 해준다.
- Scroll View와 같이 사용하여 여러 기능을 구현할 수 있다.
     
<br>

## Layout Group의 단점
- 자동으로 정리하다보니 수작업으로 위치를 잡아야 하는 UI에는 사용할수 없다.
- 자식 오브젝트가 많을 경우 성능저하를 일으킬 수 있다.

<br>

## 결론
Layout Group은 UI를 자동으로 정렬해주는 UI 컴포넌트이며, 여러 속성을 사용하여 보기 좋게 조정할 수 있다.

하지만 자동으로 정렬해주는 기능인지라 위치를 직접 잡아줘야하는 UI에는 사용할 수 없다.

<br>

## 활용법
인벤토리나 상점같이 동적 요소가 줄어들거나 늘어나면서 항목이 많은 UI를 구현해야할 때 사용할 수 있을 것 같다.

<br>

# Scroll View
Scroll View는 UI 요소가 화면의 범위를 넘어갈 때, 스크롤하여 표시하고 싶을때 사용하는 기능이다.

<br>

## 영역

### Viewport
- 유저가 실제로 볼 수 있는 범위이다.
- Viewport 영역을 벗어나면 보이지 않는다.
- Content 속성의 부모여야 한다.

### Content
- 스크롤 되는 부분이며 모든 UI는 여기에 들어온다.
- 주로 Layout Group + Content Size Fitter와 함께 쓰는 경우가 많다.

## 스크롤뷰 컴포넌트

<img width="466" height="431" alt="image" src="https://github.com/user-attachments/assets/b11c904f-f340-4986-ae90-39f1c647d1a1" />

### Horizontal / Vertical
- 수평 / 수직 스크롤을 허용할 것인가 정하는 속성

### MovementType
- 스크롤 방식을 정하는 속성
- Unrestricted : 제한없음, 영역에 상관없이 스크롤이 가능하다.
- Elastic : 기본값, 스크롤 영역을 벗어나면 다시 돌아온다.
- Clamped : 제한, 스크롤 영역을 벗어날 수 없다.

### Inertia
- 스크롤의 관성을 정하는 속성

### Scroll Sensitivity
- 마우스를 사용하였을 때 스크롤 정도를 정하는 속성

### Visibility
- Permanent : 스크롤 방향 설정을 따라간다.
- Auto Hide : Content가 짧아서 스크롤할 필요가 없으면 스크롤 바를 숨긴다.
- Auto Hide And Expand Viewport : 위와 비슷하지만 남은 스크롤바를 Viewport에 맞춰서 확장한다.

<br>

## Scroll View의 장점
- 아무리 많은 UI가 들어있어도 스크롤로 전부 볼 수 있다.
- 화면 크기와 무관하게 스크롤이 가능하다.

<br>

## Scroll View의 단점
- 잘못 사용할 경우 성능저하가 일어날 수 있다.
- 구조가 어긋나면 스크롤이 잘 작동하지 않는다.

<br>

## 결론
Scroll View는 화면을 넘어가는 UI를 스크롤로 보여주는 기능으로 Viewport, Content로 구성된 영역을 기반으로 작동한다.

Layout Group + Content Size Fitter와 함께 사용하면 쉽게 인벤토리 같은 기능을 구현할 수 있지만, 구현을 제대로 하지 못할 경우 성능저하가 있을 수 있다.

<br>

# Event System
Event System은 UI에서 사용자의 입력을 감지하고, 해당 입력을 어떤 오브젝트에 전달할지 결정하는 시스템이다.

UI의 상호작용은 Event System을 통해서 이루어진다.

### EventSystem
- 중앙 관리자 역할이며 입력이 어느 오브젝트로 전달될지 결정한다.
- Canvas를 생성할때 자동 생성되며 없으면 UI 상호작용이 작동하지 않는다.

### Event Interface
- IPointerClickHandler → 클릭

- IPointerEnterHandler → 마우스가 들어올 때

- IPointerExitHandler → 마우스가 나갈 때

- IDragHandler → 드래그

- IDropHandler → 드롭

- IScrollHandler → 스크롤 입력 ...

등등 더 있다. 이 인터페이스들을 코드에서 구현하면 기능을 사용할 수 있다.

<br>

## Event System의 장점
- 입력 처리를 자동으로 관리해준다.
- 마우스나 키보드, 터치로 입력하는걸 공통적인 방식으로 처리할 수 있게 해준다.
- 인터페이스로 원하는 방식만 가져와서 구현할 수 있다.
- 복잡한 로직을 간단한 인터페이스로 가져와서 쓸 수 있다.

<br>

## Event System의 단점
- 3D 객체와 UI 입력이 섞일 경우 Layer관리를 해줘야 한다.

<br>

## 결론
Event System은 UI의 입력을 감지하고 처리하는 시스템이며 클릭, 드래그, 등등 모든 상호작용을 관리한다.

모바일, pc 구분없이 공통적인 방식으로 구현할 수 있고, 인터페이스를 이용하여 원하는 기능을 구현한다.

<br>

## 활용법
버튼 클릭이나 마우스 포인터가 올라가 있을 때 등등 일단 UI 관련으로 상호작용이 필요할 때마다 사용하면 될 것 같다.

<br>

## async / await / Task
보통 코드는 1 실행 -> 끝날때까지 대기 -> 2 실행 이런 방식인데

서버와의 통신이나 파일 저장등 시간이 좀 오래 걸릴 수도 있는 작업이 있다.

이것들을 그냥 기다리면 게임이 끊기거나 멈출 수 있기에 async(비동기)를 사용하면 특정 작업은 뒤에서 돌리면서 다른일들 할 수 있다.

async(비동기)를 사용하면 작업을 기다리는 동안 메인 스레드를 막지 않고, 게임은 돌아가면서 작업이 뒤에서 진행된다.

### Task
- 나중에 끝날 작업을 표현하는 객체
- Task : 결과가 없는 비동기 작업
- Task<T> : 타입 결과를 나중에 돌려는 비동기 작업
- GC 가비지 컬렉션(부담 존재)

### async
- 메서드에 async를 붙이면 메서드 내에서 await를 사용할수  있게된다.
- Task가 붙어있는 메서드에 붙일경우 Task / Task<t>을 반환하는 비동기 메서드가 된다.
- async를 붙인다고 자동으로 스레드가 늘어나지는 않는다. -> 명시적 호출일때만 스레드 발생(비동기)

### await
- await는 Task가 끝날때까지 기다리지만 스레드는 차단하지 않는 동작이다.
- await 함수() 를 했을때 함수가 끝날 때까지 이 메서드는 멈춰있고, 그동안 다른 코드는 돌아가게 놔둔다. 이후 끝나면 이 줄 다음부터 이어서 실행한다.

<br>

## async / await / Task의 장점
- 코루틴보다 가독성이 좋고, await를 사용할 경우 스레드를 차단 할 경우.
- try / catch문을 사용하여 예외 처리나 오류 추적이 쉽다.
- await는 스레드를 먹지 않는다.

<br>

## async / await / Task의 단점
- void 타입에다가 사용할 경우 디버깅이 어려워진다.
- 무분별하게 사용할 경우 Task가 계속 쌓여서 성능저하가 발생한다.
- Unity에서는 MonoBehaviour와 호환성 문제로 코루틴을 더 선호하는 편이다.
- 잘못할 경우 메모리 누수의 문제가 발생할 수 있다.

<br>

## 결론
async / await / Task은 코루틴에 비해 가독성이 좋고 메인 스레드를 차단하지 않는 작업에 유리하다.

하지만 비동기 자체가 Unity에 선호되는 옵션이 아니고, 무분별하게 사용하면 성능 저하가 일어날 수 있다.

<br>

## 활용법
사용한다면 방대한 양의 데이터를 처리를 해야하거나, 서버와 통신을 할 때 사용하면 좋을 것 같다.

<br>

## 끝난 시간
<img width="2548" height="1393" alt="image" src="https://github.com/user-attachments/assets/8cd621fc-27cb-44a3-87da-e829ddece46c" />
10시 57분

총합 4시간 14분
