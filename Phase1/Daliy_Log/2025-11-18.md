# 오늘 배운것
유니티의 **FSM ,** **AI NavMesh**, **2D BlendTree(Freeform Directional)**, **Override Animator Controller**에 대해 배웠다 간단하게 정리해보자

<br>

## 시작 시간
<img width="2560" height="1440" alt="image" src="https://github.com/user-attachments/assets/332a5c3d-6a88-4eac-9772-ba52b6d2616f" />

<br>

## FSM (유한 상태 머신)
FSM는 상태를 나눠서, 지금 상태를 기반으로 동작을 처리하는 방식을 말한다.
핵심으로는 **단 하나의 상태**를 가진다.

예를 들면 
- Idle
- Walk
- Attack
- Dead

이런 느낌으로 상태를 나누고 현제 상태에 따라서 행동이 바뀌는 구조이다.

<br>

FSM의 장점
1. 코드의 가독성이 높아진다.
2. 수행하려는 동작이 뭔지 쉽게 알수있다.
3. 버그가 일어났을때의 디버깅이 쉽다.
4. 확장성이 좋다.
5. 구현이 어렵지 않다.
6. AI를 구현하기 편하다.

<br>

FSM의 단점
1. 상태가 많아질수록 구조가 많이 복잡해진다.
2. 상태가 많으면 디버깅이 어려워지고 버그 가능성을 높인다.
3. 상태가 동시에 존재해야하는 경우에는 약하다(이동 중 공격 등등)(Switch).

### 결론
FSM은 단순하게 상태가 적고 상태가 하나만 있어야 하는 상황에서 쓰기가 좋다. 그래서 코드 가독성을 높일수 있고, 다른 몬스터를 구현하더라도 상태만 같다면 코드를 추가할 필요가 없을정도로 편하지만
**상태의 수가 많거나** 상태가 **동시에 여러개가 존재하는** 경우에는 쓰기가 힘들다. 그런 경우에는 State 패턴을 사용하여 객체지향적으로 관리하는 하는것이 좋은것 같다.

<br>

### 활용법
게임내에서 간단한 몬스터나 NPC에 활용할수 있을 것 같은 구조이다.
상태가 5개 정도 되는 간단한 구조의 위주 게임이면 이 구조를 활용하는것이 좋을것 같다.
예)
- 상태가 idle, Attack, die, patrol, chase 정도 밖에 없는 경우

<br>
<br>

## AI NavMesh
AI NavMesh는 유니티에서 AI가 길을 찾아서 이동하는 기능을 만들어 주는 네비게이션 시스템이다.
장애물, 벽, 낭떠러지 등 방해 요소가 있어도 갈 수 있는 부분만 갈 수 있게 해준다.

NavMesh: AI가 이동이 가능한 길을 이미 Bake(구워둔)한 길을 말한다.

NavMeshObstacle : AI가 NavMesh 경로 계산에서 회피해야 하는 장애물을 말한다.

NavMeshAgent: 미리 Bake된 길을 보고 경로를 계산해서 찾아가는 AI를 말한다.

AI NavMesh의 장점
- 직접적으로 길찾기 알고리즘을 구현할 필요가 없다.
- 정적인 지형을 중간에 수정해도 다시 Bake만 하면 된다.
- 캐릭터의 위치에서 목표위치까지의 최단 경로를 찾아주고, 자연스럽게 동작한다.

AI NavMesh의 단점
- 지형이 바뀌면 계속 구워줘야한다.
- 지형이 움직이는 게임의 경우 적합하지가 않다.
- 2D에서는 별도의 컴포넌트를 사용해야 한다. (2D NavMeshComponents)

<br>

### 결론
AI NavMesh는 지형이 바뀌지 않는 오픈 월드 같은 장르나 맵이 움직이지 않는 게임에서 AI가 플레이어를 쫓게 하거나, 장애물이 많거나 할때 사용하기 좋다.
아니면 몬스터의 길찾기 AI를 손쉽게 구현하고 싶을때에도 좋다.

<br>

### 활용법
오픈형 월드 게임에서 상대 몬스터가 추적을 할 경우에 플레이어에게 SetDestination(target.position); 같은 구문을 써서 일정 거리를 벗어나기 전까지 길찾기를 시킬수 있다(경로가 바뀔때마다 호출).
몬스터가 특정 범위를 순찰할 때 장애물에 충돌하지 않고 순찰할수 있게 할수있다.
특수 상황에서 몬스터가 집으로 돌아가거나, 도망가는 상황에서 사용할수 있다.

<br>
<br>

# 2D BlendTree(Freeform Directional)
기본적으로 BlendTree는 애니메이션 클립을 파라미터에 따라서 블렌딩(혼합) 해주는 기능이다.
2D BlendTree는 파라미터가 2개 이기에 파라미터의 조합 따라 자유로운 전환이 가능하다.
2D BlendTree(Freeform Directional)는 BlendTree 안에 애니메이션들이 자유로운 위치에 배치되고, 입력 값의 방향에 따라서 그 주변의 애니메이션들과 섞이면서 전환되는 기능이다.
보통은 Horizontal값(X)과 Vertical값(Y)을 이용하여 사용한다.

2D BlendTree의 장점
- 방향전환이 자연스럽다.
- 속도의 크기까지 반영된다.
- 8방향이나, 보다 더 많은 방향도 부드럽게 표현할수 있다.
- 애니메이션의 혼합이 자연스럽다.

2D BlendTree의 단점
- 기본의 애니메이션 설정보다는 귀찮다.
- 애니메이션 클립이 많을수록 관리가 어렵다.(성능은 여전히 좋음)

<br>

### 결론
2D BlendTree는 캐릭터의 이동 방향 + 속도에 따라서 애니메이션을 섞어주는 기능이다.
플레이어한테는 사용하는게 좋으나, 2개의 파라미터를 전부 활용하여 플레이어를 추척하는것 같은 복잡한 몬스터가 아닌 이상에야 몬스터에게는 보통 넣지 않는다.

<br>

### 활용법
어느게임을 만들때 플레이어의 캐릭터가 위주가 되고 이동을 하는 게임이면 BlendTree를 써서 자연스러운 애니메이션을 보여주는데 사용할 수 있다.
기믹이 다양한 몬스터를 만들때 활용할수 있을것 같다.
예) 플레이어 근처 위치를 순간이동 하면서 천천히 접근하는 캐릭터

<br>

# Override Animator Controller
Override Animator Controller는 기존 Animator Controller의 구조는 그대로 가져오되, 그 안에서 사용하는 클립만 갈아끼는 기능이다.
원본 Animator Controller의 구조, 파라미터 등등은 다 가져오되 클립만 바꿔쓰는 Override(덮어쓰기)는 기능이다.

Override Animator Controller의 장점
- 동일한 애니메이션의 구조의 캐릭터가 여러명일때 Controller를 새로 만들 필요가 없음(비효율적임)
- 게임중에 애니메이션을 교체해야할때 사용할수 있음(스킨, 무기 변경 등등)
- 메모리적으로 효율적

Override Animator Controller의 단점
- 애니메이션 구조가 다르면 사용 불가
- BlendTree가 섞여있을 경우 관리가 헷갈릴수 있음(사용 가능)

<br>

### 결론
캐릭터의 무기변경이나 스킨같이 같은 구조이지만 모션만 다른경우에 쓰기 좋다.
이름만 다르고 행동 패턴이 같은 몬스터의 경우에 사용할수 있다.
BlendTree가 섞여있을경우 Override는 가능하지만 클립이 어느 위치값에 대응하는지 찾기가 힘들수는 있다.
상태 구조가 동일하다면 너무 남발하지 않는이상 단점 없이 매우 효율적인 기능이다.

<br>

### 활용법
캐릭터가 들고있는 무기를 근거리 -> 원거리로 바꾸거나 아에 종류가 바뀔때나, 캐릭터의 스킨을 바꿀때 모션만 바뀌는거라 사용하기 좋다.
행동패턴이 같은 몬스터의 경우에 Override Animator Controller로 부담가지 않게 모션을 수정해서 넣을수 있다.

<br>

## 끝난 시간
<img width="2560" height="1440" alt="image" src="https://github.com/user-attachments/assets/56c69ff4-5090-4404-9278-77213be5adb5" />

<br>

### 총 시간
1시간 45분
